import React, { useState, useReducer, createContext, useContext } from 'react';
import { useNavigate } from 'react-router-dom';
import axios from 'axios';
import ErrorCode from '../utils/ErrorCode';
import { toast } from 'react-toastify';

// üß∑ ÌòÑÏû¨ IP Ï£ºÏÜå
export const IP_ADDRESS = 'http://localhost:8080';

// üìÄ axios Ïù∏Ïä§ÌÑ¥Ïä§ : Î≤†Ïù¥Ïä§ URL Ï°∞Ï†à Í∞ÄÎä•
const instance = axios.create({
  baseURL: `${IP_ADDRESS}`,
});

// ‚ùï ÏöîÏ≤≠ Ïù∏ÌÑ∞ÏÖâÌÑ∞ : ÌÜ†ÌÅ∞Ïóê Bearer Ï≤òÎ¶¨Ïãú ÏùºÍ¥ÑÏ†ÅÏúºÎ°ú Ï†úÏñ¥
instance.interceptors.request.use(
  function (config) {
    const accessToken = localStorage.getItem('accessToken');
    const refreshToken = localStorage.getItem('refreshToken');

    if (accessToken) {
      config.headers['Authorization-Access'] = accessToken;
    }
    if (refreshToken) {
      config.headers['Authorization-Refresh'] = refreshToken;
    }
    return config;
  },

  function (error) {
    return Promise.reject(error);
  }
);

// ‚ùï Ïú†Ï†Ä ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
const initialState = {
  user: null,
};

// ‚ùï Ïï°ÏÖò ÌÉÄÏûÖ
const SET_USER = 'SET_USER';

// ‚ùï Reducer : stateÏóê Ïú†Ï†Ä ÏÉÅÌÉú Ï†ÄÏû•
const reducer = (state, action) => {
  switch (action.type) {
    case SET_USER:
      return {
        ...state,
        user: action.user, // ‚ñ∂ Ïú†Ï†ÄÏùò Ïï°ÏÖò
      };
    default:
      throw new Error(`ÌÜµÏ†úÎêòÏßÄ ÏïäÎäî ÌÉÄÏûÖ: ${action.type}`);
  }
};

// ‚ùï Context Ï†ïÏùò
const UserStateContext = createContext();
const UserDispatchContext = createContext();

export const UserProvider = ({ children }) => {
  const [state, dispatch] = useReducer(reducer, initialState); // Ïú†Ï†Ä ÏÉÅÌÉú Í≥µÏú†

  const [emailExists, setEmailExists] = useState(true); // ÌöåÏõêÍ∞ÄÏûÖ Ïãú Ïù¥Î©îÏùº Ï§ëÎ≥µ Ïó¨Î∂Ä

  const [takenTime, setTakenTime] = useState(null); // Ïù∏Ï¶ùÎ≤àÌò∏ Î∞úÍ∏âÏãúÍ∞Ñ
  const [expireTime, setExpireTime] = useState(null);

  const [verified, setVerified] = useState(false); // Ïù¥Î©îÏùº Ïù∏Ï¶ù Ïó¨Î∂Ä

  const [nameDuplicated, setNameDuplicated] = useState(true); // ÎãâÎÑ§ÏûÑ Ï§ëÎ≥µ Ïó¨Î∂Ä

  // üôç‚Äç‚ôÇÔ∏èüôç‚Äç‚ôÄÔ∏è SNS Î°úÍ∑∏Ïù∏ ÏóîÎìú Ìè¨Ïù∏Ìä∏
  const googleURL = `${IP_ADDRESS}/oauth2/authorization/google`;
  const kakaoURL = `${IP_ADDRESS}/oauth2/authorization/kakao`;
  const naverURL = `${IP_ADDRESS}/oauth2/authorization/naver`;

  const navigate = useNavigate();

  // üìß Ïù¥Î©îÏùº Ïù∏Ï¶ù ÏöîÏ≤≠ (ÌöåÏõêÍ∞ÄÏûÖÏö©) -------------------------------------------------
  const requestEmailForSignUp = async (email, emailType, socialType) => {
    const URL = `${IP_ADDRESS}/auth/email`;

    try {
      const response = await instance.post(URL, {
        email,
        emailType,
        socialType,
      });

      console.log('Î¶¨Ïä§Ìè∞Ïä§', response);

      // ‚ñ∂ 204 === Ï§ëÎ≥µ ÏïÑÎãàÍ≥†, Ïù∏Ï¶ùÎ∞úÍ∏â
      if (response.status === 204) {
        setEmailExists(false);
        setTakenTime(new Date());
        toast.success('Ïù∏Ï¶ùÎ≤àÌò∏Í∞Ä Î∞úÏÜ°ÎêòÏóàÏäµÎãàÎã§');
      } else {
        setEmailExists(true);
        toast.warning('Ïù¥ÎØ∏ ÏÑúÎ≤ÑÏóê Ï°¥Ïû¨ÌïòÎäî Ïù¥Î©îÏùºÏûÖÎãàÎã§');
      }
    } catch (error) {
      console.error('üí• Ïù¥Î©îÏùº Ïù∏Ï¶ùÎ≤àÌò∏ ÏöîÏ≤≠ Ï§ë ÏóêÎü¨ Î∞úÏÉù: ', error);
    }
  };

  // üìß Ïù¥Î©îÏùº Ïù∏Ï¶ù ÏöîÏ≤≠ (ÎπÑÎ∞ÄÎ≤àÌò∏ Ïû¨ÏÑ§Ï†ïÏö©) ---------------------------------------------
  const requestEmailForReset = async (email, emailType, socialType) => {
    const URL = `${IP_ADDRESS}/auth/email`;

    try {
      const response = await instance.post(URL, {
        email,
        emailType,
        socialType,
      });

      console.log('Î¶¨Ïä§Ìè∞Ïä§', response);

      // ‚ñ∂ 204 === Ï§ëÎ≥µÏù¥Í≥†, Ïù∏Ï¶ù Î∞úÍ∏â
      if (response.status === 204) {
        setEmailExists(true);
        setTakenTime(new Date());
        setExpireTime(
          new Date(new Date().setMinutes(new Date().getMinutes() + 10))
        );
        toast.success('Ïù∏Ï¶ùÎ≤àÌò∏Í∞Ä Î∞úÏÜ°ÎêòÏóàÏäµÎãàÎã§');
      } else {
        setEmailExists(false);
        toast.error('Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Ïù¥Î©îÏùºÏûÖÎãàÎã§');
      }
    } catch (error) {
      console.error('üí• Ïù¥Î©îÏùº Ïù∏Ï¶ùÎ≤àÌò∏ ÏöîÏ≤≠ Ï§ë ÏóêÎü¨ Î∞úÏÉù: ', error);
    }
  };

  // ‚úÖ Ïù¥Î©îÏùº Ïù∏Ï¶ù ÌôïÏù∏ ------------------------------------------------------------
  const checkCodeVerification = async (
    email,
    emailType,
    inputNum,
    socialType
  ) => {
    const NO_CODE_ERROR = 'Ïù∏Ï¶ùÎ≤àÌò∏Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî';
    const EXPIRED_CODE_ERROR = 'Ïù∏Ï¶ùÎ≤àÌò∏Í∞Ä ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§';

    // ‚ñ∂ Ïù∏Ï¶ùÎ≤àÌò∏ ÏûÖÎ†• Ïó¨Î∂Ä ÌôïÏù∏
    if (!inputNum) {
      toast.error(NO_CODE_ERROR);
      return;
    }

    // ‚ñ∂ Ïù∏Ï¶ù Ïú†Ìö® ÏãúÍ∞Ñ 10Î∂Ñ
    const timeDifference = (expireTime - takenTime) / 1000 / 60;

    if (timeDifference > 10) {
      toast.error(EXPIRED_CODE_ERROR);
      return;
    }

    try {
      const response = await instance.post(
        `${IP_ADDRESS}/auth/register/authentication/number`,
        {
          email,
          emailType,
          inputNum,
          socialType,
        }
      );

      if (response.status === 204) {
        setVerified(true);
        toast.success('Ïù∏Ï¶ù ÏôÑÎ£å!');
      } else {
        toast.error('Ïù∏Ï¶ù Ïã§Ìå®;');
      }
    } catch (error) {
      console.error('üí• Ïù∏Ï¶ù ÌôïÏù∏ Ï§ë ÏóêÎü¨ Î∞úÏÉù: ', error);
    }
  };

  // ‚ùì ÎãâÎÑ§ÏûÑ Ï§ëÎ≥µ ÌôïÏù∏
  const checkNameDuplication = async (nickName) => {
    try {
      const response = await instance.post(
        `${IP_ADDRESS}/auth/register/authentication/nickname`,
        {
          nickName,
        }
      );

      if (response.data.isDuplicated) {
        setNameDuplicated(true);
        toast.warning('Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî ÎãâÎÑ§ÏûÑÏûÖÎãàÎã§');
      } else {
        setNameDuplicated(false);
        toast.success('ÏÇ¨Ïö©Í∞ÄÎä•Ìïú ÎãâÎÑ§ÏûÑÏûÖÎãàÎã§:)');
      }
    } catch (error) {
      console.error('üí• ÎãâÎÑ§ÏûÑ Ï§ëÎ≥µ ÌôïÏù∏ Ï§ë ÏóêÎü¨ Î∞úÏÉù: ', error);
    }
  };

  // üìù ÌöåÏõêÍ∞ÄÏûÖ ---------------------------------------------------------------
  const signup = (email, password, nickName, socialType) => {
    const URL = `${IP_ADDRESS}/auth/register`;

    instance
      .post(
        URL,
        {
          email: email,
          password: password,
          nickName: nickName,
          socialType: socialType,
        },
        {
          headers: {
            'Content-Type': 'application/json;charset=UTF-8',
            Accept: 'application/json',
          },
        }
      )
      .then((result) => {
        console.log(`ÌöåÏõêÍ∞ÄÏûÖ ÏöîÏ≤≠ ÏÑ±Í≥µ : ${result}`);
        toast.sucess('ÌöåÏõêÍ∞ÄÏûÖÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!');
        navigate('/login');
      })
      .catch((error) => {
        console.log(error);
        toast.error('üí• ÌöåÏõêÍ∞ÄÏûÖ Ï§ë ÏóêÎü¨ Î∞úÏÉù');
      });
  };

  // üö´ ÌöåÏõêÌÉàÌá¥ ---------------------------------------------------------------
  const deleteUser = async () => {
    const URL = `${IP_ADDRESS}/auth/delete-user`;
    const socialId = localStorage.getItem('socialId');

    try {
      await instance.delete(URL, {
        data: { socialId },
      });

      // ‚ñ∂ Î°úÍ∑∏ÏïÑÏõÉ Ï≤òÎ¶¨
      logout();

      toast.success('ÌöåÏõêÌÉàÌá¥Í∞Ä ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.');
    } catch (error) {
      console.error('üí• ÌöåÏõêÌÉàÌá¥ ÏöîÏ≤≠ Ï§ë ÏóêÎü¨ Î∞úÏÉù: ', error);
    }
  };

  // üîê Î°úÍ∑∏Ïù∏ ---------------------------------------------------------------
  const login = (email, password, socialType) => {
    const URL = `${IP_ADDRESS}/token/login`;

    instance
      .post(
        URL,
        {
          email: email,
          password: password,
          socialType: socialType,
        },
        {
          headers: {
            'Content-Type': 'application/json;charset=UTF-8',
            Accept: 'application/json',
            'Access-Control-Allow-Origin': '*',
          },
        }
      )
      .then((response) => {
        console.log('Î°úÍ∑∏Ïù∏ ÎêòÏóàÏäµÎãàÎã§!');

        localStorage.setItem(
          'accessToken',
          response.headers['authorization-access']
        );
        localStorage.setItem(
          'refreshToken',
          response.headers['authorization-refresh']
        );
        localStorage.setItem('nickName', response.headers.get('nickName'));
        localStorage.setItem('socialId', response.headers.get('socialId'));
        localStorage.setItem('socialType', socialType);
        localStorage.setItem('email', email);

        // ‚ñ∂ Ïú†Ï†Ä Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
        let user = {
          socialId: response.headers['socialId'],
          socialType: socialType,
          nickName: response.headers['nickName'],
          email,
          password,
        };

        dispatch({ type: SET_USER, user });
        toast.success('Î°úÍ∑∏Ïù∏ ÎêòÏóàÏäµÎãàÎã§!');
        navigate('/main');
      })
      .catch((error) => {
        // ÏóêÎü¨ ÏÉÅÌÉú ÏΩîÎìúÏóê Îî∞Î•∏ Î©îÏãúÏßÄ ÌëúÏãú
        if (error.response && error.response.status) {
          switch (error.response.status) {
            case ErrorCode.NOT_EXIST_USER_EMAIL_SOCIALTYPE.status:
              toast.error(ErrorCode.NOT_EXIST_USER_EMAIL_SOCIALTYPE.message);
              break;
            case ErrorCode.NOT_VALID_ACCESSTOKEN.status:
              toast.error(ErrorCode.NOT_VALID_ACCESSTOKEN.message);
              break;
            default:
              toast.error('üí• Î°úÍ∑∏Ïù∏ Ïã§Ìå®!');
          }
        } else {
          toast.error('üí• Î°úÍ∑∏Ïù∏ Ïã§Ìå®!');
        }
      });
  };

  //üîì Î°úÍ∑∏ÏïÑÏõÉ ---------------------------------------------------------------
  const logout = async () => {
    const URL = `${IP_ADDRESS}/token/logout`;
    const accessToken = localStorage.getItem('accessToken');

    try {
      const response = await instance.post(URL, {
        headers: {
          'Authorization-Access': accessToken,
        },
      });

      if (response.status === 204) {
        console.log(response.status);

        // ‚ñ∂ Ïú†Ï†Ä Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        localStorage.removeItem('socialid');
        localStorage.removeItem('nickName');
        localStorage.removeItem('email');
        localStorage.removeItem('socialType');

        // ‚ñ∂ Ïú†Ï†Ä ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
        dispatch({ type: SET_USER, user: null });

        // ‚ñ∂ Ïú†Ï†Ä ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
        toast.success('Î°úÍ∑∏ÏïÑÏõÉ ÎêòÏóàÏäµÎãàÎã§!');

        // ‚ñ∂ Redirect
        navigate('/main');
      }
    } catch (error) {
      console.log(error);
      toast.error('üí• Î°úÍ∑∏ÏïÑÏõÉÏóê Î¨∏Ï†úÍ∞Ä ÏÉùÍ≤ºÏäµÎãàÎã§!');
    }
  };

  // üîÑ ÎπÑÎ∞ÄÎ≤àÌò∏ Ïû¨ÏÑ§Ï†ï ---------------------------------------------------------------
  const resetPassword = async (email, password, rePassword, socialType) => {
    try {
      const response = await instance.post(
        `${IP_ADDRESS}/auth/reset/password`,
        {
          email,
          password,
          rePassword,
          socialType,
        }
      );

      if (response.status === 204) {
        toast.success('ÎπÑÎ∞ÄÎ≤àÌò∏Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ïû¨ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§');
      } else {
        toast.error('üí• ÎπÑÎ∞ÄÎ≤àÌò∏ Ïû¨ÏÑ§Ï†ïÏóê Ïã§Ìå®ÌïòÏòÄÏäµÎãàÎã§');
      }
    } catch (error) {
      console.error('üí• ÎπÑÎ∞ÄÎ≤àÌò∏ Ïû¨ÏÑ§Ï†ï Ï§ë ÏóêÎü¨ Î∞úÏÉù: ', error);
    }

    navigate('/login');
  };

  // üöÄ ÏÉàÎ°úÏö¥ Ïï°ÏÑ∏Ïä§ ÌÜ†ÌÅ∞ Î∞úÍ∏â -----------------------------------------------------------
  const reIssue = async () => {
    const URL = `${IP_ADDRESS}/reissue`;
    const socialType = localStorage.getItem('socialType');
    const accessToken = localStorage.getItem('accessToken');
    const refreshToken = localStorage.getItem('refreshToken');

    try {
      const response = await instance.post(URL, {
        headers: {
          'Authorization-Access': accessToken,
          'Authorization-Refresh': refreshToken,
        },
      });

      if (response.status === 204 && socialType === 'Refrigerator-Alchemist') {
        localStorage.setItem('accessToken', response.data.accessToken);
        console.log(
          `ÏÉàÎ°úÏö¥ Ïï°ÏÑ∏Ïä§ ÌÜ†ÌÅ∞ÏùÑ Î∞úÍ∏âÎ∞õÏïòÏäµÎãàÎã§ : ${response.data.accessToken}`
        );
        navigate(window.location.pathname);
      }

      if (response.status === 204 && socialType !== 'Refrigerator-Alchemist') {
        localStorage.setItem(
          'accessToken',
          'Bearer ' + response.data.accessToken
        );
        console.log(
          `ÏÉàÎ°úÏö¥ Ïï°ÏÑ∏Ïä§ ÌÜ†ÌÅ∞ÏùÑ Î∞úÍ∏âÎ∞õÏïòÏäµÎãàÎã§ : ${response.data.accessToken}`
        );
        navigate(window.location.pathname);
      }
    } catch (error) {
      console.error('üí• ÏÉàÎ°úÏö¥ Ïï°ÏÑ∏Ïä§ ÌÜ†ÌÅ∞ Î∞úÍ∏â Ïã§Ìå®', error);
      toast.error('üí• ÏÉàÎ°úÏö¥ Ïï°ÏÑ∏Ïä§ ÌÜ†ÌÅ∞ Î∞úÍ∏â Ïã§Ìå®');
    }
  };

  // üü° Ïπ¥Ïπ¥Ïò§ --------------------------------------------------
  const kakaoLogin = () => {
    window.location.href = kakaoURL;
    console.log('Ïπ¥Ïπ¥Ïò§ Î°úÍ∑∏Ïù∏ ÌéòÏù¥ÏßÄ Ï†ëÏÜç');
  };

  // üî¥ Íµ¨Í∏Ä ----------------------------------------------------
  const googleLogin = () => {
    window.location.href = googleURL;
    console.log('Íµ¨Í∏Ä Î°úÍ∑∏Ïù∏ ÌéòÏù¥ÏßÄ Ï†ëÏÜç');
  };

  // üü¢ ÎÑ§Ïù¥Î≤Ñ --------------------------------------------------
  const naverLogin = () => {
    window.location.href = naverURL;
    console.log('ÎÑ§Ïù¥Î≤Ñ Î°úÍ∑∏Ïù∏ ÌéòÏù¥ÏßÄ Ï†ëÏÜç');
  };

  // ‚ù§ DispatchÏóê Îã¥Í∏∏ value
  const value = {
    state,
    dispatch,
    login,
    logout,
    signup,
    deleteUser,
    resetPassword,
    requestEmailForSignUp,
    requestEmailForReset,
    setEmailExists,
    emailExists,
    checkCodeVerification,
    verified,
    setVerified,
    checkNameDuplication,
    nameDuplicated,
    setNameDuplicated,
    reIssue,
    kakaoLogin,
    googleLogin,
    naverLogin,
  };

  return (
    <UserDispatchContext.Provider value={value}>
      <UserStateContext.Provider value={state}>
        {children}
      </UserStateContext.Provider>
    </UserDispatchContext.Provider>
  );
};

// üî± UserStateÏùÑ ÏÇ¨Ïö© Í∞ÄÎä•ÌïòÍ≤å ÌïòÎäî ÌõÖ
export const useUserState = () => {
  const context = useContext(UserStateContext);
  if (!context) {
    throw new Error('Cannot find UserProvider');
  }
  return context;
};

// üî± UserDispatchÎ•º ÏÇ¨Ïö© Í∞ÄÎä•ÌïòÍ≤å ÌïòÎäî ÌõÖ
export const useUserDispatch = () => {
  const context = useContext(UserDispatchContext);
  if (!context) {
    throw new Error('Cannot find UserProvider');
  }
  return context;
};
